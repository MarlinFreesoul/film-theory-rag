<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”µå½±åˆ›ä½œæµ - ä¸‰ç»´å¯¼èˆªå¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            position: relative;
        }

        /* å·¦ä¾§å¯¹è¯åŒºåŸŸ */
        .dialogue-panel {
            width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .dialogue-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .dialogue-header h1 {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .session-info {
            font-size: 12px;
            opacity: 0.9;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .message {
            margin-bottom: 15px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            text-align: right;
        }

        .message-content {
            display: inline-block;
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 12px;
            word-wrap: break-word;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.assistant .message-content {
            background: #f3f4f6;
            color: #1f2937;
        }

        .input-area {
            padding: 20px;
            border-top: 1px solid #e5e7eb;
            background: white;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
        }

        #userInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        #userInput:focus {
            border-color: #667eea;
        }

        #sendBtn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s;
        }

        #sendBtn:hover {
            transform: translateY(-2px);
        }

        #sendBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* å³ä¾§å¯è§†åŒ–ç”»å¸ƒ */
        .canvas-panel {
            flex: 1;
            position: relative;
            background: rgba(255, 255, 255, 0.1);
        }

        /* ä¸‰ç»´å¯¼èˆªæŒ‡ç¤ºå™¨ */
        .navigation-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 5;
        }

        .nav-title {
            font-size: 14px;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 15px;
        }

        /* äº”é˜¶æ®µè¿›åº¦æ¡ */
        .stage-progress {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stage-item {
            flex: 1;
            text-align: center;
            position: relative;
        }

        .stage-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e5e7eb;
            margin: 0 auto 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #9ca3af;
            transition: all 0.3s;
        }

        .stage-item.active .stage-dot {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .stage-item.completed .stage-dot {
            background: #10b981;
            color: white;
        }

        .stage-label {
            font-size: 12px;
            color: #6b7280;
        }

        .stage-item.active .stage-label {
            color: #667eea;
            font-weight: 600;
        }

        /* è¿æ¥çº¿ */
        .stage-item:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 20px;
            left: calc(50% + 20px);
            width: calc(100% - 40px);
            height: 2px;
            background: #e5e7eb;
        }

        .stage-item.completed:not(:last-child)::after {
            background: #10b981;
        }

        /* ç»“æ„å±‚çº§æŒ‡ç¤ºå™¨ */
        .structure-indicator {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .structure-level {
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            background: #f3f4f6;
            color: #6b7280;
            transition: all 0.3s;
        }

        .structure-level.active {
            background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }

        /* æ€ç»´å¯¼å›¾ç”»å¸ƒ */
        #flowCanvas {
            width: 100%;
            height: calc(100% - 140px);
            margin-top: 140px;
        }

        /* å³ä¸‹è§’ç¼©ç•¥å›¾ */
        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 2px solid #e5e7eb;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ */
        .detail-panel {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 350px;
            max-height: 80vh;
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            overflow: hidden;
            display: none;
            z-index: 20;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from { opacity: 0; transform: translate(20px, -50%); }
            to { opacity: 1; transform: translate(0, -50%); }
        }

        .detail-panel.show {
            display: block;
        }

        .detail-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .detail-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .detail-type {
            font-size: 12px;
            opacity: 0.9;
        }

        .detail-content {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(80vh - 140px);
        }

        .detail-section {
            margin-bottom: 20px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 8px;
        }

        .detail-text {
            font-size: 14px;
            color: #1f2937;
            line-height: 1.6;
        }

        .detail-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .detail-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* åŠ è½½çŠ¶æ€ */
        .loading {
            display: none;
            align-items: center;
            gap: 8px;
            color: #667eea;
            font-size: 13px;
            padding: 8px 0;
        }

        .loading.show {
            display: flex;
        }

        .loading-dots {
            display: flex;
            gap: 4px;
        }

        .loading-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #667eea;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¦ä¾§å¯¹è¯é¢æ¿ -->
        <div class="dialogue-panel">
            <div class="dialogue-header">
                <h1>ç”µå½±åˆ›ä½œåŠ©æ‰‹</h1>
                <div class="session-info">
                    <span>ä¼šè¯ID: <span id="sessionId">-</span></span> |
                    <span>è½®æ¬¡: <span id="turnNumber">0</span></span>
                </div>
            </div>

            <div class="messages" id="messages">
                <div class="message assistant">
                    <div class="message-content">
                        ä½ å¥½ï¼æˆ‘æ˜¯ç”µå½±åˆ›ä½œåŠ©æ‰‹ã€‚è¯·å‘Šè¯‰æˆ‘ä½ æƒ³åˆ›ä½œä»€ä¹ˆæ ·çš„ç”µå½±ï¼Ÿ
                    </div>
                </div>
            </div>

            <div class="input-area">
                <div class="loading" id="loading">
                    <div class="loading-dots">
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                    </div>
                    <span>æ€è€ƒä¸­...</span>
                </div>
                <div class="input-wrapper">
                    <input
                        type="text"
                        id="userInput"
                        placeholder="è¾“å…¥ä½ çš„æƒ³æ³•..."
                        autocomplete="off"
                    />
                    <button id="sendBtn">å‘é€</button>
                </div>
            </div>
        </div>

        <!-- å³ä¾§å¯è§†åŒ–ç”»å¸ƒ -->
        <div class="canvas-panel">
            <!-- ä¸‰ç»´å¯¼èˆªæŒ‡ç¤ºå™¨ -->
            <div class="navigation-indicator">
                <div class="nav-title">åˆ›ä½œæµç¨‹å¯¼èˆª</div>

                <!-- äº”é˜¶æ®µè¿›åº¦ -->
                <div class="stage-progress">
                    <div class="stage-item active" data-stage="clarify">
                        <div class="stage-dot">1</div>
                        <div class="stage-label">æ˜ç¡®</div>
                    </div>
                    <div class="stage-item" data-stage="focus">
                        <div class="stage-dot">2</div>
                        <div class="stage-label">èšç„¦</div>
                    </div>
                    <div class="stage-item" data-stage="diverge">
                        <div class="stage-dot">3</div>
                        <div class="stage-label">å‘æ•£</div>
                    </div>
                    <div class="stage-item" data-stage="converge">
                        <div class="stage-dot">4</div>
                        <div class="stage-label">æ”¶æ•›</div>
                    </div>
                    <div class="stage-item" data-stage="organize">
                        <div class="stage-dot">5</div>
                        <div class="stage-label">æ•´ç†</div>
                    </div>
                </div>

                <!-- ç»“æ„å±‚çº§ -->
                <div class="structure-indicator">
                    <div class="structure-level" data-level="3">ç¬¬ä¸‰ç»“æ„ (æ„å›¾å±‚)</div>
                    <div class="structure-level active" data-level="2">ç¬¬äºŒç»“æ„ (éšå–»å±‚)</div>
                    <div class="structure-level" data-level="1">ç¬¬ä¸€ç»“æ„ (æ•…äº‹å±‚)</div>
                </div>
            </div>

            <!-- æ€ç»´å¯¼å›¾ç”»å¸ƒ -->
            <canvas id="flowCanvas"></canvas>

            <!-- ç¼©ç•¥å›¾ -->
            <div class="minimap">
                <canvas id="minimapCanvas" class="minimap-canvas"></canvas>
            </div>
        </div>

        <!-- èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ -->
        <div class="detail-panel" id="detailPanel">
            <button class="detail-close" id="closeDetail">Ã—</button>
            <div class="detail-header">
                <div class="detail-title" id="detailTitle">æ ‡é¢˜</div>
                <div class="detail-type" id="detailType">ç±»å‹</div>
            </div>
            <div class="detail-content" id="detailContent">
                <!-- åŠ¨æ€å†…å®¹ -->
            </div>
        </div>
    </div>

    <script>
        // ===== é…ç½® =====
        const API_URL = 'http://localhost:8001';

        // ===== çŠ¶æ€ç®¡ç† =====
        let state = {
            sessionId: null,
            turnNumber: 0,
            currentStage: 'clarify',
            currentStructure: 2,
            nodes: [],
            edges: [],
            offset: { x: 0, y: 0 },
            scale: 1,
            isDragging: false,
            dragStart: { x: 0, y: 0 }
        };

        // ===== DOM å…ƒç´  =====
        const elements = {
            messages: document.getElementById('messages'),
            userInput: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
            sessionId: document.getElementById('sessionId'),
            turnNumber: document.getElementById('turnNumber'),
            loading: document.getElementById('loading'),
            detailPanel: document.getElementById('detailPanel'),
            detailTitle: document.getElementById('detailTitle'),
            detailType: document.getElementById('detailType'),
            detailContent: document.getElementById('detailContent'),
            closeDetail: document.getElementById('closeDetail'),
            canvas: document.getElementById('flowCanvas'),
            minimap: document.getElementById('minimapCanvas')
        };

        // ===== Canvas è®¾ç½® =====
        const ctx = elements.canvas.getContext('2d');
        const minimapCtx = elements.minimap.getContext('2d');

        function resizeCanvas() {
            elements.canvas.width = elements.canvas.offsetWidth;
            elements.canvas.height = elements.canvas.offsetHeight;
            elements.minimap.width = 200;
            elements.minimap.height = 150;
            renderCanvas();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ===== èŠ‚ç‚¹ç±»å‹é…ç½® =====
        const nodeStyles = {
            input: { color: '#667eea', icon: 'ğŸ’­', width: 200, height: 80 },
            keyword: { color: '#10b981', icon: 'ğŸ”‘', width: 180, height: 70 },
            theory: { color: '#3b82f6', icon: 'ğŸ“š', width: 200, height: 90 },
            work: { color: '#8b5cf6', icon: 'ğŸ¬', width: 200, height: 90 },
            scene: { color: '#f59e0b', icon: 'ğŸ¥', width: 200, height: 90 },
            question: { color: '#ef4444', icon: 'â“', width: 220, height: 80 }
        };

        // ===== æ¸²æŸ“ç”»å¸ƒ =====
        function renderCanvas() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);

            ctx.save();
            ctx.translate(state.offset.x, state.offset.y);
            ctx.scale(state.scale, state.scale);

            // ç»˜åˆ¶è¿æ¥çº¿
            state.edges.forEach(edge => {
                const from = state.nodes.find(n => n.id === edge.from);
                const to = state.nodes.find(n => n.id === edge.to);
                if (!from || !to) return;

                ctx.beginPath();
                ctx.moveTo(from.x + from.width / 2, from.y + from.height / 2);
                ctx.lineTo(to.x + to.width / 2, to.y + to.height / 2);
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 2;
                ctx.stroke();

                // ç®­å¤´
                drawArrow(ctx,
                    from.x + from.width / 2, from.y + from.height / 2,
                    to.x + to.width / 2, to.y + to.height / 2
                );
            });

            // ç»˜åˆ¶èŠ‚ç‚¹
            state.nodes.forEach(node => {
                const style = nodeStyles[node.type];

                // èŠ‚ç‚¹èƒŒæ™¯
                ctx.fillStyle = node.selected ? '#1f2937' : style.color;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;

                roundRect(ctx, node.x, node.y, node.width, node.height, 12, true);

                ctx.shadowBlur = 0;

                // å›¾æ ‡
                ctx.font = '24px Arial';
                ctx.fillText(style.icon, node.x + 15, node.y + 35);

                // æ–‡æœ¬
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                wrapText(ctx, node.label, node.x + 50, node.y + 25, node.width - 60, 18);
            });

            ctx.restore();

            // æ¸²æŸ“ç¼©ç•¥å›¾
            renderMinimap();
        }

        function roundRect(ctx, x, y, width, height, radius, fill) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split('');
            let line = '';
            let currentY = y;
            let lineCount = 0;
            const maxLines = 2;

            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i];
                const metrics = ctx.measureText(testLine);

                if (metrics.width > maxWidth && i > 0) {
                    if (lineCount < maxLines - 1) {
                        ctx.fillText(line, x, currentY);
                        line = words[i];
                        currentY += lineHeight;
                        lineCount++;
                    } else {
                        ctx.fillText(line + '...', x, currentY);
                        return;
                    }
                } else {
                    line = testLine;
                }
            }
            if (lineCount < maxLines) {
                ctx.fillText(line, x, currentY);
            }
        }

        function drawArrow(ctx, fromX, fromY, toX, toY) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const headLength = 10;

            ctx.beginPath();
            ctx.moveTo(toX - headLength * Math.cos(angle - Math.PI / 6),
                      toY - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6),
                      toY - headLength * Math.sin(angle + Math.PI / 6));
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function renderMinimap() {
            minimapCtx.clearRect(0, 0, 200, 150);

            if (state.nodes.length === 0) return;

            // è®¡ç®—è¾¹ç•Œ
            const bounds = {
                minX: Math.min(...state.nodes.map(n => n.x)),
                maxX: Math.max(...state.nodes.map(n => n.x + n.width)),
                minY: Math.min(...state.nodes.map(n => n.y)),
                maxY: Math.max(...state.nodes.map(n => n.y + n.height))
            };

            const scale = Math.min(
                180 / (bounds.maxX - bounds.minX),
                130 / (bounds.maxY - bounds.minY)
            );

            minimapCtx.save();
            minimapCtx.translate(10, 10);
            minimapCtx.scale(scale, scale);
            minimapCtx.translate(-bounds.minX, -bounds.minY);

            state.nodes.forEach(node => {
                const style = nodeStyles[node.type];
                minimapCtx.fillStyle = style.color;
                minimapCtx.fillRect(node.x, node.y, node.width, node.height);
            });

            minimapCtx.restore();
        }

        // ===== æ·»åŠ èŠ‚ç‚¹ =====
        function addNode(type, label, data, parentId = null) {
            const nodeId = `${type}-${Date.now()}-${Math.random()}`;
            const style = nodeStyles[type];

            // è®¡ç®—ä½ç½® (ä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹å¸ƒå±€)
            let x = 100;
            let y = 100;

            if (parentId) {
                const parent = state.nodes.find(n => n.id === parentId);
                if (parent) {
                    // å­èŠ‚ç‚¹å‘å³ä¸‹åç§»
                    const siblings = state.nodes.filter(n =>
                        state.edges.some(e => e.from === parentId && e.to === n.id)
                    );
                    x = parent.x + 300;
                    y = parent.y + siblings.length * 120;
                }
            } else {
                // æ ¹èŠ‚ç‚¹å±…ä¸­
                const roots = state.nodes.filter(n =>
                    !state.edges.some(e => e.to === n.id)
                );
                y = roots.length * 120 + 100;
            }

            const node = {
                id: nodeId,
                type,
                label,
                data,
                x,
                y,
                width: style.width,
                height: style.height,
                selected: false
            };

            state.nodes.push(node);

            if (parentId) {
                state.edges.push({ from: parentId, to: nodeId });
            }

            renderCanvas();
            return nodeId;
        }

        // ===== ç”»å¸ƒäº¤äº’ =====
        elements.canvas.addEventListener('mousedown', (e) => {
            const rect = elements.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - state.offset.x) / state.scale;
            const y = (e.clientY - rect.top - state.offset.y) / state.scale;

            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»èŠ‚ç‚¹
            const clickedNode = state.nodes.find(node =>
                x >= node.x && x <= node.x + node.width &&
                y >= node.y && y <= node.y + node.height
            );

            if (clickedNode) {
                // é€‰ä¸­èŠ‚ç‚¹å¹¶æ˜¾ç¤ºè¯¦æƒ…
                state.nodes.forEach(n => n.selected = false);
                clickedNode.selected = true;
                showNodeDetail(clickedNode);
                renderCanvas();
            } else {
                // å¼€å§‹æ‹–åŠ¨ç”»å¸ƒ
                state.isDragging = true;
                state.dragStart = { x: e.clientX - state.offset.x, y: e.clientY - state.offset.y };
            }
        });

        elements.canvas.addEventListener('mousemove', (e) => {
            if (state.isDragging) {
                state.offset.x = e.clientX - state.dragStart.x;
                state.offset.y = e.clientY - state.dragStart.y;
                renderCanvas();
            }
        });

        elements.canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
        });

        elements.canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            state.scale = Math.max(0.5, Math.min(2, state.scale * delta));
            renderCanvas();
        });

        // ===== æ˜¾ç¤ºèŠ‚ç‚¹è¯¦æƒ… =====
        function showNodeDetail(node) {
            elements.detailTitle.textContent = node.label;
            elements.detailType.textContent = `ç±»å‹: ${getNodeTypeName(node.type)}`;

            let html = '';

            if (node.type === 'keyword') {
                html = `<div class="detail-text">${node.label}</div>`;
            } else if (node.type === 'theory') {
                html = `
                    <div class="detail-section">
                        <div class="detail-label">ç†è®ºåç§°</div>
                        <div class="detail-text">${node.data.title || node.label}</div>
                    </div>
                    <div class="detail-section">
                        <div class="detail-label">ç†è®ºè¯´æ˜</div>
                        <div class="detail-text">${node.data.explanation || '-'}</div>
                    </div>
                `;
            } else if (node.type === 'work') {
                html = `
                    <div class="detail-section">
                        <div class="detail-label">ä½œå“åç§°</div>
                        <div class="detail-text">${node.data.title || node.label}</div>
                    </div>
                    <div class="detail-section">
                        <div class="detail-label">åˆ›ä½œè€…</div>
                        <div class="detail-text">${node.data.creator || '-'}</div>
                    </div>
                    <div class="detail-section">
                        <div class="detail-label">å‚è€ƒç‚¹</div>
                        <div class="detail-text">${node.data.reference_point || '-'}</div>
                    </div>
                `;
            } else if (node.type === 'scene') {
                html = `
                    <div class="detail-section">
                        <div class="detail-label">ğŸ¥ ç”»é¢æè¿°</div>
                        <div class="detail-text">${node.data.visual || '-'}</div>
                    </div>
                    <div class="detail-section">
                        <div class="detail-label">ğŸ”Š å£°éŸ³è®¾è®¡</div>
                        <div class="detail-text">${node.data.sound || '-'}</div>
                    </div>
                    <div class="detail-section">
                        <div class="detail-label">â±ï¸ æ—¶é•¿</div>
                        <div class="detail-text">${node.data.duration || '-'}</div>
                    </div>
                    <div class="detail-section">
                        <div class="detail-label">ğŸ¯ ç›®çš„</div>
                        <div class="detail-text">${node.data.purpose || '-'}</div>
                    </div>
                `;
            } else if (node.type === 'question') {
                html = `<div class="detail-text">${node.label}</div>`;
            } else {
                html = `<div class="detail-text">${node.label}</div>`;
            }

            elements.detailContent.innerHTML = html;
            elements.detailPanel.classList.add('show');
        }

        function getNodeTypeName(type) {
            const names = {
                input: 'ç”¨æˆ·è¾“å…¥',
                keyword: 'å…³é”®è¯',
                theory: 'ç†è®ºçµæ„Ÿ',
                work: 'ä½œå“å‚è€ƒ',
                scene: 'è§†è§‰åœºæ™¯',
                question: 'å¼•å¯¼é—®é¢˜'
            };
            return names[type] || type;
        }

        elements.closeDetail.addEventListener('click', () => {
            elements.detailPanel.classList.remove('show');
            state.nodes.forEach(n => n.selected = false);
            renderCanvas();
        });

        // ===== æ›´æ–°å¯¼èˆªæŒ‡ç¤ºå™¨ =====
        function updateNavigation(stage, structure) {
            state.currentStage = stage;
            state.currentStructure = structure;

            // æ›´æ–°é˜¶æ®µè¿›åº¦
            const stageMap = {
                'clarify': 0,
                'focus': 1,
                'diverge': 2,
                'converge': 3,
                'organize': 4
            };

            document.querySelectorAll('.stage-item').forEach((item, index) => {
                item.classList.remove('active', 'completed');
                const currentIndex = stageMap[stage];
                if (index < currentIndex) {
                    item.classList.add('completed');
                } else if (index === currentIndex) {
                    item.classList.add('active');
                }
            });

            // æ›´æ–°ç»“æ„å±‚çº§
            document.querySelectorAll('.structure-level').forEach(item => {
                item.classList.remove('active');
                if (parseInt(item.dataset.level) === structure) {
                    item.classList.add('active');
                }
            });
        }

        // ===== å‘é€æ¶ˆæ¯ =====
        async function sendMessage() {
            const input = elements.userInput.value.trim();
            if (!input) return;

            // æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
            addMessage('user', input);
            elements.userInput.value = '';
            elements.sendBtn.disabled = true;
            elements.loading.classList.add('show');

            // æ·»åŠ ç”¨æˆ·è¾“å…¥èŠ‚ç‚¹
            const inputNodeId = addNode('input', input, { text: input });

            try {
                const response = await fetch(`${API_URL}/inspire`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_input: input,
                        session_id: state.sessionId
                    })
                });

                const data = await response.json();

                // æ›´æ–°çŠ¶æ€
                state.sessionId = data.session_id;
                state.turnNumber = data.turn_number;
                elements.sessionId.textContent = data.session_id.substring(0, 8);
                elements.turnNumber.textContent = data.turn_number;

                // æ›´æ–°å¯¼èˆª (å‡è®¾é˜¶æ®µå’Œç»“æ„å±‚çº§ä»åç«¯è¿”å›)
                const stage = data.state?.stage || 'clarify';
                const structure = 2; // é»˜è®¤ç¬¬äºŒç»“æ„
                updateNavigation(stage, structure);

                // å¤„ç†è¿”å›å†…å®¹
                let responseText = '';
                let lastNodeId = inputNodeId;

                // å…³é”®è¯
                if (data.keywords && data.keywords.length > 0) {
                    responseText += `å…³é”®è¯: ${data.keywords.join(', ')}\n`;
                    data.keywords.forEach(kw => {
                        const kwId = addNode('keyword', kw, { keyword: kw }, lastNodeId);
                        lastNodeId = kwId;
                    });
                }

                // ç†è®ºçµæ„Ÿ
                if (data.theory_inspirations && data.theory_inspirations.length > 0) {
                    data.theory_inspirations.forEach(theory => {
                        responseText += `\nç†è®º: ${theory.title}\n${theory.explanation}\n`;
                        addNode('theory', theory.title, theory, lastNodeId);
                    });
                }

                // ä½œå“å‚è€ƒ
                if (data.work_inspirations && data.work_inspirations.length > 0) {
                    data.work_inspirations.forEach(work => {
                        responseText += `\nä½œå“: ${work.title} (${work.creator})\n`;
                        addNode('work', work.title, work, lastNodeId);
                    });
                }

                // è§†è§‰åœºæ™¯
                if (data.visual_scenes && data.visual_scenes.length > 0) {
                    data.visual_scenes.forEach(scene => {
                        responseText += `\nåœºæ™¯: ${scene.title}\n`;
                        addNode('scene', scene.title, scene, lastNodeId);
                    });
                }

                // å¼•å¯¼é—®é¢˜
                if (data.guiding_questions && data.guiding_questions.length > 0) {
                    const question = data.guiding_questions[0];
                    responseText += `\n${question.question}`;
                    addNode('question', question.question, question, lastNodeId);
                }

                addMessage('assistant', responseText || 'æ€è€ƒä¸­...');

            } catch (error) {
                console.error('Error:', error);
                addMessage('assistant', 'æŠ±æ­‰,å‡ºç°äº†é”™è¯¯ã€‚è¯·é‡è¯•ã€‚');
            } finally {
                elements.sendBtn.disabled = false;
                elements.loading.classList.remove('show');
            }
        }

        function addMessage(role, content) {
            const div = document.createElement('div');
            div.className = `message ${role}`;
            div.innerHTML = `<div class="message-content">${content}</div>`;
            elements.messages.appendChild(div);
            elements.messages.scrollTop = elements.messages.scrollHeight;
        }

        // ===== äº‹ä»¶ç›‘å¬ =====
        elements.sendBtn.addEventListener('click', sendMessage);
        elements.userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // ===== åˆå§‹åŒ– =====
        console.log('ç”µå½±åˆ›ä½œæµå¯è§†åŒ–ç³»ç»Ÿå·²å¯åŠ¨');
    </script>
</body>
</html>
